name: Publish Docker Image

on:
  workflow_call:
    inputs:
      environment:
        type: string
        required: false
        description: 'The environment to publish the Docker image to.'
      tags:
        type: string
        required: true
        description: 'The tags to apply to the Docker image.'
      images:
        type: string
        required: true
        description: 'The images to publish'
      trigger_internal_ci:
        description: 'Trigger the internal CI'
        required: false
        type: boolean
        default: false
  workflow_dispatch:
    inputs:
      trigger_internal_ci:
        description: 'Trigger the internal CI'
        required: true
        type: boolean
        default: false

permissions:
  contents: read
  packages: write

jobs:
  build-and-push-image:
    name: Build and Push Docker Image
    strategy:
      fail-fast: false
      matrix:
        include:
          - runs_on: ubuntu-22.04
            platform: linux/amd64
          - runs_on: ubuntu-22.04-arm
            platform: linux/arm64
    runs-on: ${{ matrix.runs_on }}

    environment: ${{ inputs.environment }}
    steps:

      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        # Only log in to Docker Hub if the event is a release
        if: ${{ inputs.environment == 'docker-publish' && github.event_name != 'pull_request' }}
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Log in to the Container registry
        uses: docker/login-action@v3
        if: ${{ github.event_name != 'pull_request' }}
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          # default to ghcr.io for workflow_dispatch
          images: ${{ inputs.images || format('ghcr.io/{0}', github.repository) }}
          # use the branch + sha if workflow_dispatch
          tags: ${{ inputs.tags || format('type=raw,value={0}-{1}', github.ref_name, github.sha) }}

      - name: Compute cache scopes
        # BuildKit GHA cache scopes to avoid cross-arch/branch clobbering.
        # Shared scope depends on TARGET branch (PRs use github.base_ref):
        #   - default(master)   -> shared-default
        #   - release/* -> shared-release-<release-branch>
        # Writes per event:
        #   - pull_request           : read shared+branch, write branch
        #   - workflow_dispatch      : if TARGET is master/release/* write shared+branch; else like PR
        #   - push (master/release/*): read shared, write shared+branch
        id: cache
        shell: bash
        env:
          REPO: ${{ github.repository }}
          PLATFORM: ${{ matrix.platform }}
          REF: ${{ github.ref_name }}
          EVENT: ${{ github.event_name }}
          DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
          BASE_REF: ${{ github.base_ref }}
        run: |
          set -euo pipefail
          # Determine TARGET branch for shared cache (master or a specific release/*)
          TARGET_REF="${REF}"
          if [ "${EVENT}" = "pull_request" ] && [ -n "${BASE_REF}" ]; then
            TARGET_REF="${BASE_REF}"
          fi
          if [ "${TARGET_REF}" = "${DEFAULT_BRANCH}" ]; then
            SHARED_SUFFIX="default"
          elif [[ "${TARGET_REF}" == release/* ]]; then
            SANITIZED_TARGET=$(echo "${TARGET_REF}" | sed 's|/|-|g')
            SHARED_SUFFIX="release-${SANITIZED_TARGET}"
          else
            SHARED_SUFFIX="default"
          fi
          SHARED="${REPO}-${PLATFORM}-shared-${SHARED_SUFFIX}"
          BRANCH="${REPO}-${PLATFORM}-${REF}"
          case "${EVENT}" in
            pull_request)
              FROM=$(printf '%s\n' "type=gha,scope=${SHARED}" "type=gha,scope=${BRANCH}")
              TO=$(printf '%s\n' "type=gha,mode=max,scope=${BRANCH}")
              ;;
            workflow_dispatch)
              if [ "${TARGET_REF}" = "${DEFAULT_BRANCH}" ] || [[ "${TARGET_REF}" == release/* ]]; then
                FROM=$(printf '%s\n' "type=gha,scope=${SHARED}")
                TO=$(printf '%s\n' "type=gha,mode=max,scope=${SHARED}" "type=gha,mode=max,scope=${BRANCH}")
              else
                FROM=$(printf '%s\n' "type=gha,scope=${SHARED}" "type=gha,scope=${BRANCH}")
                TO=$(printf '%s\n' "type=gha,mode=max,scope=${BRANCH}")
              fi
              ;;
            *)
              FROM=$(printf '%s\n' "type=gha,scope=${SHARED}")
              TO=$(printf '%s\n' "type=gha,mode=max,scope=${SHARED}" "type=gha,mode=max,scope=${BRANCH}")
              ;;
          esac
          echo "from<<EOF" >> "$GITHUB_OUTPUT"; echo "${FROM}" >> "$GITHUB_OUTPUT"; echo "EOF" >> "$GITHUB_OUTPUT"
          echo "to<<EOF"   >> "$GITHUB_OUTPUT"; echo "${TO}"   >> "$GITHUB_OUTPUT"; echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Compute arch-suffixed tags
        id: tags
        shell: bash
        env:
          META_TAGS: ${{ steps.meta.outputs.tags }}
        run: |
          set -euo pipefail
          case "${{ matrix.platform }}" in
            linux/amd64) ARCH="amd64" ;;
            linux/arm64) ARCH="arm64" ;;
            *) echo "Unsupported platform: ${{ matrix.platform }}" >&2; exit 1 ;;
          esac
          TMP_FILE="$(mktemp)"
          printf '%s\n' "${META_TAGS}" | awk -v a="$ARCH" 'NF{print $0 "-" a}' > "$TMP_FILE"
          if [ ! -s "$TMP_FILE" ]; then
            echo "No arch-suffixed tags produced" >&2
            exit 1
          fi
          echo "tags<<EOF" >> "$GITHUB_OUTPUT"
          cat "$TMP_FILE" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"
          rm -f "$TMP_FILE"

      - name: Build and push (${{ matrix.platform }})
        id: build
        if: ${{ github.event_name != 'pull_request' || matrix.platform == 'linux/amd64' }}
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: ${{ matrix.platform }}
          push: ${{ github.event_name != 'pull_request' }}
          load: ${{ github.event_name == 'pull_request' }}
          provenance: ${{ github.event_name != 'pull_request' }}
          sbom: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.tags.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: ${{ steps.cache.outputs.from }}
          cache-to:   ${{ steps.cache.outputs.to }}

      - name: Compute safe platform name
        id: platform
        shell: bash
        run: |
          SAFE=$(echo "${{ matrix.platform }}" | tr '/' '_')
          echo "safe=${SAFE}" >> $GITHUB_OUTPUT

      - name: Export digest
        if: ${{ github.event_name != 'pull_request' }}
        shell: bash
        run: |
          PLATFORM="${{ matrix.platform }}"
          SAFE="${PLATFORM//\//_}"
          echo "${{ steps.build.outputs.digest }}" > "digest-${SAFE}.txt"

      - name: Upload digest artifact
        if: ${{ github.event_name != 'pull_request' }}
        uses: actions/upload-artifact@v4
        with:
          name: digest-${{ steps.platform.outputs.safe }}
          path: digest-${{ steps.platform.outputs.safe }}.txt

      - name: Scan for vulnerabilities
        uses: crazy-max/ghaction-container-scan@v3
        if: ${{ (github.event_name == 'pull_request' && matrix.platform == 'linux/amd64') || (github.ref_name == 'master' && matrix.platform == 'linux/amd64') }}
        with:
          image: ${{ github.event_name == 'pull_request' && steps.tags.outputs.tags || fromJSON(steps.meta.outputs.json).tags[0] }}
          annotations: true
          severity: LOW
          dockerfile: ./Dockerfile
        env:
          # See https://github.com/aquasecurity/trivy/discussions/7538
          TRIVY_DB_REPOSITORY: public.ecr.aws/aquasecurity/trivy-db:2

  merge-manifest:
    name: Create multi-arch manifest
    needs: [build-and-push-image]
    if: ${{ github.event_name != 'pull_request' }}
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout Repo
        uses: actions/checkout@v4

      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        if: ${{ inputs.environment == 'docker-publish' }}
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          # default to ghcr.io for workflow_dispatch
          images: ${{ inputs.images || format('ghcr.io/{0}', github.repository) }}
          # use the branch + sha if workflow_dispatch
          tags: ${{ inputs.tags || format('type=raw,value={0}-{1}', github.ref_name, github.sha) }}

      - name: Download digests
        uses: actions/download-artifact@v4
        with:
          pattern: digest-*
          path: ./digests
          merge-multiple: true

      - name: Create and push manifest list
        env:
          TAGS: ${{ steps.meta.outputs.tags }}
          IMAGE: ${{ inputs.images || format('ghcr.io/{0}', github.repository) }}
        shell: bash
        run: |
          AMD64_DIGEST=$(cat digests/digest-linux_amd64.txt)
          ARM64_DIGEST=$(cat digests/digest-linux_arm64.txt)
          TAG_ARGS=""
          while IFS= read -r tag; do
            [ -z "$tag" ] && continue
            TAG_ARGS="$TAG_ARGS -t $tag"
          done <<< "$TAGS"
          docker buildx imagetools create \
            $TAG_ARGS \
            "$IMAGE@${AMD64_DIGEST}" \
            "$IMAGE@${ARM64_DIGEST}"
